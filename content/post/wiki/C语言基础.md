---
title: C语言基础
tags:
- C语言
categories:
- wiki
- C
toc: true
date: 2014-09-18 19:25:00
---

参加了联咏电子的笔试发现C语言的基础是多么差，痛心疾首后还是安下心来学习，以此为鉴。

## 补码
首先是计算机对数据的表示，在计算机的世界里只有0/1之分，没有数值的正负之分。但我们现实世界的数值是有正负的，为了解决这一矛盾，我们约定使用最高位来表示正负，剩余位表示数值的大小。0表示正数，1表示负数。
为什么要这样约定呢？为什么不用0表示负数，1表示正数？
在此有一个“模”的概念，详见[百度百科-补码](http://baike.baidu.com/view/377340.htm?fr=aladdin)。其中的一个例子是
```
假设当前时针指向10点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨4小时，即：10-4=6；另一种是顺拨8小时：10+8=12+6=6
在以12模的系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。对“模”而言，8和4互为补数。实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特性。共同的特点是两者相加等于模。
```
在计算机的世界中，（在此以8位为例）只能表示0000 0000 ~ 1111 1111共256个数。因此“模”为256。正数很好表示，就为0、1、2...，那负数就是-1（0-1），-2（0-2），-3（0-3）...，如上的12模所示，-1就可以用0-1 = 0+（256-1）表示，即为255，用二进制表示就是1111 11111。现在我们要抛弃255这个数，就是说计算机只存在1111 1111，并不知道这是个啥意思。这是我们用0-1计算出来的，因此我们把这个数叫-1，即这是-1在计算机世界的表示，学名叫补码。

我们可以认为只有负数才有补码，正数就是原来的数，不用转换。
补码的计算方法就是所能表示的数值个数（即为“模”）减去负数的大小。用二进制的直接做法是符号不变，数值按位取反，然后整个数加1。
至于什么补码的表示范围是-128~127？我们用0000 0000至1111 1111组成一个圆圈，从0000 0000开始顺时针加1，逆时针减1，这样就表示了8bit能表示的数值范围。正负数的表示的交接处是1000 0000和01111 1111。为了统一起始位的正负，所以1000 0000表示-128。这样负数是128个数，正数（算上零）也是128个数，多么和谐！

## 数据类型转换
1. 相同大小的signed和unsigned
两者所存储的二进制是一样的，就看各自的解释了。比如char -128,转换成unsigned char就是128，因为两者的二进制都是1000 0000。
2. signed之间的从小转大
用符号位扩展至对应大小，这样保证了结果不变。比如char -4,转换成int还是-4，但是从0xfc转换为了0xffff fffc。
3. unsigned之间的从小转大
高位补0。实际上同signed之间是一样的，要保证结果不变。
4. signed之间的从大转小
直接进行二进制截取。就是大数先用二进制表示出来，再截取所用的位数。比如int -500转换为char变成12。从0xffff fe0c转换成0x0c。
